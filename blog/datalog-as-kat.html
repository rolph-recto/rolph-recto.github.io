<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="dcterms.date" content="2024-07-09" />
  <title>Rolph
Recto – Encoding Datalog in Kleene Algebra with Tests</title>
  <style>
    html {
      line-height: 1.4;
      font-size: 1.1em;
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 800px;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    p {
      margin: 1em 0;
    }
    figure {
      text-align: center;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      text-align: left;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    /* CSS for syntax highlighting */
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { color: #008000; } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { color: #008000; font-weight: bold; } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"
  type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<b>Rolph Recto</b> - <a href="/">Home</a>
<hr />
<h1 class="title">Encoding Datalog in Kleene Algebra with Tests</h1>
<p>July 09, 2024</p>
<p><em>Kleene algebra with tests</em> (KAT) is a useful extension of
Kleene algebras invented by Dexter Kozen that roughly corresponds to
“while” programs. (TODO cite). KATs have been used in a variety of
domains, mostly famously in networking with the NetKAT project, where
KATs are used to model both the forwarding policy of switches and the
topology of the network. In this post, I’ll talk about how you can also
use KATs to model the fixpoint semantics of Datalog programs.</p>
<p>Recall that a Datalog program is a set of rules of the form <span
class="math inline">\(R \leftarrow Q_1, \ldots, Q_n\)</span></p>
<p>The <em>Herbrand universe</em> for a Datalog program relative to a
database is the set of all constants that appear within the program or
within the facts of the database. The</p>
<p>Given a Datalog program and a database, we can define an
<em>immediate consequence operator</em> <span
class="math inline">\(T\)</span> as follows:</p>
<p><span class="math display">\[
T(I) = \{ A_0 \mid A_0 \leftarrow A_1, \ldots, A_n \in
\textup{ground}(P_D), \forall 1 \leq i \leq n. A_i \in I \}
\]</span></p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> T(I): <span class="co"># immediate consequence operator</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    out <span class="op">=</span> <span class="bu">set</span>()</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> rule <span class="kw">in</span> ground_rules(P, D):</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">all</span>((atom <span class="kw">in</span> I) <span class="cf">for</span> atom <span class="kw">in</span> rule.body):</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>            out.add(rule.head)</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> out</span></code></pre></div>
<p>Note that <span class="math inline">\(T\)</span> is monotonic: if
<span class="math inline">\(I_1 \subseteq I_2\)</span> then <span
class="math inline">\(T(I_1) \subseteq T(I_2)\)</span>. Because of this,
by Knaster-Tarski</p>
<p>Importantly, <span class="math inline">\(T\)</span> is
<em>monotonic</em>: for all <span class="math inline">\(I\)</span>,
<span class="math inline">\(I \subseteq T(I)\)</span>. This means that
the immediate consequence operator only ever adds ground atoms, it never
removes them.</p>
<p>We are now ready to encode a Datalog program and its fixpoint
semantics as a KAT; let’s call it DKAT. We define a DKAT over a set of
ground atoms <span class="math inline">\(A\)</span>.</p>
<p><span class="math display">\[
\begin{align}
[\![ \cdot ]\!] &amp;: \textup{St} \rightarrow \mathcal{P}(\textup{St})
\\
[\![ 1 ]\!](s) &amp;= \{ s \} \\
[\![ 0 ]\!](s) &amp;= \emptyset \\
[\![ p \cdot q ]\!]  &amp;= \\
\end{align}
\]</span></p>
<p><span class="math display">\[
A_0 \leftarrow A_1, \ldots A_n
\; \;
\leadsto
\; \;
A_1? \ldots A_n? A_0!
\]</span></p>
<p><span class="math display">\[
\left ( \prod E_i \right ) \times \left ( \sum A_1? \ldots A_n? A_0!
\right )^*
\]</span></p>
<p>We can describe properties of a Datalog program directly with this
encoding</p>
<p><span class="math display">\[
\left ( \prod E_i \right ) \times \left ( \sum A_1? \ldots A_n? A_0!
\right )^* = \{ s \}.
\]</span></p>
<p>for some state <span class="math inline">\(s\)</span>.</p>
<h2 id="handling-negation">Handling Negation</h2>
<p>So far</p>
<p>Note that DKAT as presented here is close to the one found in the KAT
+ B! paper, except there are no setters that can set facts to be false.
There is no need for that because the head of a Datalog rule cannot be
negated. The semantics of DKAT as a function of states is similar to the
semantics of NetKAT, except that NetKAT is defined as functions over
<em>histories</em> of packets. The encoding of the fixpoint semantics
for a Datalog program is also reminiscent of the <em>logical
crossbar</em> expression for NetKAT, which models the end-to-end
forwarding behavior of a network.</p>
</body>
</html>
